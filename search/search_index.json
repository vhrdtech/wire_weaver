{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WireWeaver","text":"<p>WireWeaver is a wire format and API code generator for resource constrained systems (for example microcontrollers). It allows you to define data types, methods, properties and streams and generate code that uses no standard library or memory allocation. Unsized types - <code>Vec&lt;T&gt;</code>, String and others are supported (even on no_std without allocator!). Backwards and forwards compatibility is supported: devices with older format version can communicate with newer ones and vice versa.</p> <p>Currently only Rust language is supported, with the idea to handle device communications in Rust and provide higher level bindings for C++, Python or other languages if needed.</p> <p>Current state is - highly experimental.</p>"},{"location":"api/","title":"API","text":"<p>Define a custom protocol as collections of resources - methods, properties or streams and generate server and client side code. Multiple levels are supported, each resource is identified via a number path from root, forming a tree. Efficient path is used, consisting of UNib32 encoded numbers, taking as little as 4 bits.</p> <p>Resources can be arranged into \"ww-trait's\" and then \"implemented\" at various points in the API tree. Accessing them is possible in the same manner via resource paths, or through their globally unique ID (crate name + version or unique ID + version). Many useful \"ww-traits\" are planned, implementing things like firmware update, event counters, logging, power management, etc. That way code to handle them all can be reused greatly between very different projects. UI can also be arranged into small reusable blocks.</p> <p>Two models are planned: client-server and bus. Client-server model is functional (<code>ww_client_server</code> crate) and supported in code generation for both server and client side, std and no_std. Bus model is still in development.</p>"},{"location":"api/#methods","title":"Methods","text":""},{"location":"api/#async-and-sync","title":"Async and sync","text":""},{"location":"api/#deferred-and-immediate","title":"Deferred and Immediate","text":""},{"location":"api/#streams","title":"Streams","text":"<pre><code>trait Log {\n    fn defmt_bytes() -&gt; Stream&lt;u8&gt;;\n    fn sink(stream_in: Sink&lt;u8&gt;);\n}\n</code></pre>"},{"location":"api/#properties","title":"Properties","text":""},{"location":"api/#getset-and-value-on-change","title":"Get/Set and value on change","text":""},{"location":"api/#traits","title":"Traits","text":""},{"location":"api/#user-handler-flattening-no_std","title":"User handler flattening (no_std)","text":""},{"location":"api/#resource-arrays","title":"Resource arrays","text":"<p>Any resource can also be an array - method, property, stream and trait implementation:</p> <pre><code>trait ArrayOf {\n    fn run&lt;N: u32&gt;();\n    stream!(adc[]: u16);\n    property!(led[]: bool);\n    ww_impl!(motor[]: ww_motor_control::Motor);\n}\n</code></pre> <p>TODO: size bounds</p> <p>Traits inside other traits can also contain arrays, all the indices leading up to them are accumulated and passed as Rust array <code>[u32; N]</code> argument into a corresponding user handler.</p>"},{"location":"api/#array-of-resources-vs-resource-of-array","title":"Array of resources vs resource of array","text":"<p>Here, resource led is itself an array, when accessing it - an index will be added to the resource path. Each one of three bool's is accessed separately from each other.</p> <pre><code>trait ArrayOfResources {\n    property!(led[3]: bool);\n}\n</code></pre> <p>On the other hand, here led is not an array, but it's type is. All three boolean's are accessed in one go.</p> <pre><code>trait ResourceOfArrays {\n    property!(led: [bool; 3]);\n}\n</code></pre> <p>Both can be used together as well, for example:</p> <pre><code>trait ArrayOfArrays {\n    property!(rgb_led[3]: [u8; 3]);\n}\n</code></pre>"},{"location":"api/#transport-protocols","title":"Transport protocols","text":"<p>Several transport protocols are supported:</p> <ul> <li>USB (nusb on host side, embassy on embedded, no drivers needed on Windows/Mac/Linux)</li> <li>WebSocket (for reliable control access)</li> <li>UDP (for telemetry)</li> <li>TODO: CAN Bus (using CANOpen)</li> </ul> <p>Others could be easily implemented, possibly reusing the same code.</p> <p>USB and UDP transports support multiple events per packet/datagram. Many small messages can be accumulated over a time window conserving bandwidth and allowing much higher message throughput per unit of time that would otherwise be possible with one message per packet/datagram.</p>"},{"location":"versioning/","title":"Versioning","text":"<p>Each type and \"ww-trait\" version is it's crate version, same versioning rules apply. Types and \"ww-trait's\" are globally identified by their crate name and version. <code>FullVersion</code> type is provided in <code>ww_version</code> crate that carries crate name in addition to version numbers.</p>"},{"location":"versioning/#compact-ww-trait-version","title":"Compact ww-trait version","text":"<p>There is a possibility to make API calls on \"ww-traits\", without knowing the exact resource path. For example one could make a \"sleep\" call on all devices in a CAN Bus network, that support \"PowerManagement\" trait. Or \"get_fw_version\" on any device supporting \"FirmwareInfo\" trait. In order to do so, instead of relying on resource path (a vector of numbers from API root), <code>FullVersion</code> is sent instead.</p> <p>Compared to resource paths that can only take a few bytes (numbers are UNib32 encoded, so the smallest path is 4 bits), <code>FullVersion</code> is likely to take about 8-16 bytes or more and vary with the crate name. This is unfortunate for constrained systems, or if one want to pack many calls into one packet.</p> <p>Solution to this is <code>CompactVersion</code>, which carries globally unique type id and major.minor version components only, all UNib32 encoded. The only downside is that guaranteeing globally unique IDs is not as simple as using crate's name anymore. IDs are manually assigned and tracked via git instead.</p>"},{"location":"format/wire/","title":"Wire format","text":"<p>All serializing and deserializing operations are going through a wire format called <code>shrink_wrap</code>. It is targeting both microcontroller and host usage.</p> <p>Features:</p> <ul> <li>1-bit, 4-bit and 1-byte alignment</li> <li>Support all the types described above</li> <li><code>no_std</code> without allocator support (even with types like String and Vec, for both reading and writing)</li> <li><code>std</code> support (standard Vec and String are used)</li> <li>Used in auto-generated serdes and API code</li> <li>Can be used stand-alone as well</li> </ul>"},{"location":"types/alignment/","title":"Alignment","text":"<p>Some types are one- or four-bit aligned and the rest are one-byte aligned. Dense packing is used to save space, including in enum discriminants (which can even be U1). Byte arrays, strings, and Unsized objects are all one-byte aligned to limit code complexity and computations required. Unused bits are set to zero and can be reclaimed when evolving a type.</p> <p>For example:</p> <pre><code>fn version1() {\n    let mut buf = [0u8; 8];\n    let mut wr = BufWriter::new(&amp;mut buf[..]);\n    wr.write_bool(true).unwrap();\n    wr.write_u8(0xAA).unwrap();\n    let bytes = wr.finish_and_take().unwrap();\n    assert_eq!(bytes, &amp;[0x80, 0xAA]);\n}\n</code></pre> <p>In a future version while older one is still in use, it was decided to add some more data:</p> <pre><code>fn version1_1() {\n    let mut buf = [0u8; 8];\n    let mut wr = BufWriter::new(&amp;mut buf[..]);\n    wr.write_bool(true).unwrap();\n    wr.write(&amp;Some(U6::new(5).unwrap())).unwrap();\n    wr.write_u8(0xAA).unwrap();\n    let bytes = wr.finish_and_take().unwrap();\n    assert_eq!(bytes, &amp;[0xC5, 0xAA]);\n}\n</code></pre> <p>Older code can still read new data and will skip the Option, and newer code can read old data, yielding None. All the while, the serialized size didn't even change (it could have though, it's just an example).</p>"},{"location":"types/built-in/","title":"Built-in types","text":"<ul> <li>Boolean (one-bit alignment): <code>bool</code></li> <li>Discrete numbers:<ul> <li>Signed (one-byte alignment): <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code></li> <li>Unsigned (one-byte alignment): <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></li> <li>Unsigned (four-bit alignment): <code>u4</code></li> <li>Signed and unsigned (one-bit alignment): <code>iN</code> and <code>uN</code> (<code>U1</code>, <code>U2</code>, <code>U3</code>, ... <code>U64</code>, <code>I2</code> ... <code>I64</code>)</li> </ul> </li> <li>Nibble-based variable length u32: <code>UNib32</code> (1 to 11 nibbles)</li> <li>Floating point numbers: <code>f32</code>, <code>f64</code></li> <li>Textual:<ul> <li>UTF-8 string <code>String</code></li> <li>TODO: With max bounded length</li> </ul> </li> <li>Sequences:<ul> <li>Arrays:<ul> <li>Arbitrary length array: <code>Vec&lt;T&gt;</code></li> <li>Byte array: <code>Vec&lt;u8&gt;</code></li> <li>Arbitrary length array (no alloc): <code>RefVec&lt;'i, T&gt;</code></li> <li>Byte array (no alloc): <code>RefVec&lt;'i, u8&gt;</code></li> <li>TODO: Max bounded</li> <li>TODO: Fixed length array: <code>[T; N]</code></li> </ul> </li> </ul> </li> <li><code>Option&lt;T&gt;</code> and <code>Result&lt;T, E&gt;</code></li> <li> <p>User-defined:</p> <ul> <li>Struct</li> <li>Enum with or without data variants</li> </ul> </li> <li> <p>Not yet supported or not decided whether to support:</p> <ul> <li>Tuple</li> <li>Unicode character: <code>char</code> (4B)</li> <li>ASCII character <code>c_char</code> (1B) (ASCII) and string: <code>c_str</code></li> <li>Map</li> </ul> </li> </ul>"},{"location":"types/library/","title":"Library types","text":"<ul> <li>ww_numeric<ul> <li><code>NumericValue</code>: value of the supported numeric types</li> <li><code>NumericBaseType</code>: discrete, floating and fixed point number types</li> <li><code>NumericAnyType</code>: base types + subtype and shift-scale</li> </ul> </li> <li>ww_si - SI and derived values using <code>NumericValue</code> as storage</li> <li>ww_date_time<ul> <li><code>DateTime</code>: ISO 8601 combined date and time with optional time zone and optional nanoseconds.   Minimum size is 32 bits.</li> <li><code>NaiveDate</code>: ISO 8601 calendar date without timezone. Year stored as shifted by 2025, minimum size is 13 bits.</li> <li><code>NaiveTime</code>: ISO 8601 time without timezone. Size is 18 bits without nanoseconds and 49 bits with nanoseconds.</li> </ul> </li> <li>ww_version<ul> <li><code>Version</code>: SemVer version (including pre and build strings), no alloc</li> <li><code>VersionOwned</code>: SemVer version, same as <code>Version</code> but uses String's</li> <li><code>CompactVersion</code>: Global type id + major and minor version numbers, uses UNib32 for all three</li> </ul> </li> <li>ww_client_server - <code>Request</code>, <code>RequestKind</code>, <code>Event</code>, <code>EventKind</code>, <code>Error</code> used for client-server API model.</li> <li>ww_can_bus - CAN Bus types and API</li> <li>ww_dfu - Firmware update API</li> <li>ww_log_bare_metal - Logging types and API for no_std bare metal targets</li> <li>ww_self - WireWeaver of WireWeaver itself for dynamic access to APIs, expression eval and introspection.</li> </ul>"}]}