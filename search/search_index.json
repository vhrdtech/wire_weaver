{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>WireWeaver is an API code generator for microcontrollers, supporting user-defined types, methods, properties, streams, and traits. It handles unsized types like Vec and String even in no_std environments without an allocator, and ensures full backward and forward compatibility between devices across format versions."},{"location":"#recommended-learning-order","title":"Recommended learning order","text":"<ol> <li>Get familiar with the SerDes functionality: wire format    and derive macro.</li> <li>See the full list of supported types.</li> <li>Understand API capabilities.</li> <li>See it in action on real hardware or on virtual device template.</li> <li>Read the rest of the docs, in particular: evolution rules, versioning    and addressing.</li> </ol>"},{"location":"dev_tool/","title":"Dev GUI tool","text":"<p>Working features:</p> <ul> <li>Load and parse format definition file</li> <li>Show internal AST</li> <li>Show generated serdes code</li> <li>Show generated client-server code</li> <li>no_std switch to quickly view how embedded vs host code looks like</li> </ul> <p>Planned features:</p> <ul> <li>Provide input and output widgets for various types (number with SI support as spinner / dial / slide, string,   color, ...)</li> <li>Generate documentation like UI with the ability to interact with server code</li> <li>Generate server mockup UI with the ability to respond with user input, prerecorded answers or examples</li> <li>Support for bytecode loading to extract types and api information</li> <li>Support for source loading from external sources and compiling to bytecode (through Rust lib FFI or backend service)</li> </ul>"},{"location":"types/","title":"Built-in types","text":"<ul> <li>Boolean (one-bit alignment): <code>bool</code></li> <li>Discrete numbers:<ul> <li>Signed (one-byte alignment): <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code></li> <li>Unsigned (one-byte alignment): <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></li> <li>Unsigned (four-bit alignment): <code>u4</code></li> <li>Signed and unsigned (one-bit alignment): <code>iN</code> and <code>uN</code> (<code>U1</code>, <code>U2</code>, <code>U3</code>, ... <code>U64</code>, <code>I2</code> ... <code>I64</code>)</li> </ul> </li> <li>Nibble-based variable length u32: <code>UNib32</code> (1 to 11 nibbles)</li> <li>Floating point numbers: <code>f32</code>, <code>f64</code></li> <li>Textual:<ul> <li>UTF-8 string <code>String</code></li> <li>TODO: With max bounded length</li> </ul> </li> <li>Sequences:<ul> <li>Arrays:<ul> <li>Arbitrary length array: <code>Vec&lt;T&gt;</code></li> <li>Byte array: <code>Vec&lt;u8&gt;</code></li> <li>Arbitrary length array (no alloc): <code>RefVec&lt;'i, T&gt;</code></li> <li>Byte array (no alloc): <code>RefVec&lt;'i, u8&gt;</code></li> <li>TODO: Max bounded</li> <li>TODO: Fixed length array: <code>[T; N]</code></li> </ul> </li> </ul> </li> <li><code>Option&lt;T&gt;</code> and <code>Result&lt;T, E&gt;</code></li> <li><code>RefBox&lt;T&gt;</code> for self-referential types.</li> <li> <p>User-defined:</p> <ul> <li>Struct</li> <li>Enum with or without data variants</li> </ul> </li> <li> <p>Not yet supported or not decided whether to support:</p> <ul> <li>Tuple</li> <li>Unicode character: <code>char</code> (4B)</li> <li>ASCII character <code>c_char</code> (1B) (ASCII) and string: <code>c_str</code></li> <li>Map</li> </ul> </li> </ul>"},{"location":"types/#library-types","title":"Library types","text":"<p>There are a lot more types as a part of a standard library (date, time, version, numbers, SI units, etc.). See the overview.</p>"},{"location":"types/#self-referential-types","title":"Self-referential types","text":"<p>Self-referential types are supported through the <code>RefBox&lt;T&gt;</code>, providing similar semantics to Rust <code>Box&lt;T&gt;</code> type, but without using heap allocation on <code>no_std</code>.</p>"},{"location":"types/#alignment","title":"Alignment","text":"<p>Some types are one- or four-bit aligned and the rest are one-byte aligned. Dense packing is used to save space, including in enum discriminants (which can even be U1). Byte arrays, strings, and Unsized objects are all one-byte aligned to limit code complexity and computations required. Unused bits are set to zero and can be reclaimed when evolving a type.</p> <p>For example:</p> <pre><code>fn version1() {\n    let mut buf = [0u8; 8];\n    let mut wr = BufWriter::new(&amp;mut buf[..]);\n    wr.write_bool(true).unwrap();\n    wr.write_u8(0xAA).unwrap();\n    let bytes = wr.finish_and_take().unwrap();\n    assert_eq!(bytes, &amp;[0x80, 0xAA]);\n}\n</code></pre> <p>In a future version while older one is still in use, it was decided to add some more data:</p> <pre><code>fn version1_1() {\n    let mut buf = [0u8; 8];\n    let mut wr = BufWriter::new(&amp;mut buf[..]);\n    wr.write_bool(true).unwrap();\n    wr.write(&amp;Some(U6::new(5).unwrap())).unwrap();\n    wr.write_u8(0xAA).unwrap();\n    let bytes = wr.finish_and_take().unwrap();\n    assert_eq!(bytes, &amp;[0xC5, 0xAA]);\n}\n</code></pre> <p>Older code can still read new data and will skip the Option, and newer code can read old data, yielding None. All the while, the serialized size didn't even change (it could have though, it's just an example).</p>"},{"location":"types/#todo-subtypes-bounded-numbers-and-array-lengths","title":"TODO: Subtypes (bounded numbers and array lengths)","text":"<p>Simple checked numbers where only a range of values is allowed:</p> <ul> <li><code>u16&lt;{1..=512}&gt;</code></li> </ul> <p>Set of allowed values:</p> <ul> <li><code>u8&lt;{0..=8}, 12, 16, 20, 24, 32, 48, 64&gt;</code></li> </ul> <p>Numbers are checked before serialization and after deserialization.</p>"},{"location":"types/#todo-si-support","title":"TODO: SI support","text":"<p>Specify SI unit for any number:</p> <ul> <li>current: <code>f32&lt;\"A\"&gt;</code></li> <li>velocity: <code>f32&lt;\"m/s\"&gt;</code></li> </ul> <p>Units are not transmitted over the wire, used as a hint for code generation and in UI tool.</p>"},{"location":"api/addressing/","title":"Resources addressing","text":"<p>Primary mode of addressing to uniquely identify a resource (method, property, stream or trait) is an array of indices, starting from an API root. It is the most efficient way as well, utilising UNib32 variable length numbers based on nibbles (e.g., <code>[0, 1, 2]</code> is only 2 bytes, including array length).</p> <p>For example, <code>turn_on</code> address is <code>[0]</code> and <code>turn_off</code> is <code>[1]</code>.</p> <pre><code>#[ww_trait]\ntrait ApiRoot {\n    fn turn_on();\n    fn turn_off();\n}\n</code></pre> <p>As a user, you do not have to worry about these indices, as they are automatically assigned and actual names are used in generated code.</p> <p>When a resource is an array, one more index is added, selecting the required one. On the server code side this index is passed as an additional argument to user handler function.</p> <p>There could be multiple arrays on the way to a resource (e.g., array of trait implementations and then an array of resources inside said trait). Multiple indices are added in the appropriate positions in this case.</p> <p>Using this scheme requires knowing exactly which API and it's exact version that peer implements. When this is not possible or not desired (e.g., if addressing multiple nodes at the same time) - trait addressing can be used.</p>"},{"location":"api/addressing/#global-trait-addressing-fullversion","title":"Global trait addressing (FullVersion)","text":"<p>There is a possibility to make API calls on \"ww-traits\", without knowing the exact resource address. For example one could make a \"sleep\" call on all devices in a CAN Bus network, that support \"PowerManagement\" trait. Or \"get_fw_version\" on any device supporting \"FirmwareInfo\" trait. In order to do so, instead of relying on resource address, <code>FullVersion</code> is sent instead.</p> <p>Compared to resource addresses that can only take a few bytes, <code>FullVersion</code> is likely to take about 8-16 bytes or more and vary with the crate name. This is unfortunate for constrained systems, or if one wants to pack many calls into one packet.</p>"},{"location":"api/addressing/#global-trait-addressing-compactversion","title":"Global trait addressing (CompactVersion)","text":"<p>Solution to this is <code>CompactVersion</code>, which carries globally unique type id and major.minor version components only, all UNib32 encoded. The only downside is that guaranteeing globally unique IDs is not as simple as using crate's name anymore. IDs are manually assigned and tracked via git instead in ww_global registry.</p>"},{"location":"api/addressing/#api-report","title":"API report","text":"<p>TODO: export a file describing all levels of API with IDs</p>"},{"location":"api/detailed/","title":"Detailed usage","text":""},{"location":"api/detailed/#methods","title":"Methods","text":""},{"location":"api/detailed/#async-and-sync","title":"Async and sync","text":""},{"location":"api/detailed/#deferred-and-immediate","title":"Deferred and Immediate","text":""},{"location":"api/detailed/#streams","title":"Streams","text":""},{"location":"api/detailed/#properties","title":"Properties","text":""},{"location":"api/detailed/#getset-and-value-on-change","title":"Get/Set and value on change","text":""},{"location":"api/detailed/#traits","title":"Traits","text":""},{"location":"api/detailed/#user-handler-flattening-no_std","title":"User handler flattening (no_std)","text":""},{"location":"api/overview/","title":"High-level overview","text":"<p>API is defined as a collections of user-defined types and resources - methods, properties, streams and traits. Intended crate organisation is as follows:</p> <p></p> <ul> <li><code>my_device_api</code> crate - contains user-defined types and resources, common to firmware and it's driver (server and   client).   This crate must support <code>no_std</code> and optionally <code>std</code>.</li> <li>MCU firmware depends on the API crate, uses common data types and implements a server. WireWeaver generates   serdes and dispatch code, while user provides actual implementation.</li> <li>Rust driver also depends on the API crate (optionally with std feature). WireWeaver generates serdes and client side   code, user can optionally provide a higher-level client implementation on top of the generated one.</li> <li>CLI, GUI and other applications depend on the Rust driver crate in order to communicate with the device.</li> <li>Python wrapper is also automatically generated and uses Rust driver code.</li> </ul> <p>Name of the API crate (from Cargo.toml) is assumed to be a globally unique identifier (see <code>ww_version::FullVersion</code>), hence it is advised to eventually publish it to crates.io if you are working on an open-source project or ensure to use unique enough name for internal use.</p> <p>Version of the API crate is used for compatibility checks upon connection to the device. You can use it in your code as well, to show proper messages to user when interacting with an older or newer firmware from the perspective of the driver. Normal SemVer rules apply.</p> <p>WireWeaver supports both backwards and forwards compatibility at the wire format level, but you need to ensure to follow the evolution rules for this to work properly.</p>"},{"location":"api/overview/#methods","title":"Methods","text":"<p>Methods are defined using standard Rust syntax. Any number of arguments are supported and they can be of any type (supported by SerDes).</p> <pre><code>#[ww_trait]\ntrait MyDevice {\n    fn led_on();\n    fn set_brightness(value: f32);\n    fn temperature() -&gt; f32;\n    fn user_type(state: LedState);\n}\n\n#[derive_shrink_wrap]\n#[ww_repr(unib32)]\npub enum LedState {\n    Off,\n    On,\n}\n</code></pre> <p>On the server side, this is how generated server code is tied with user provided implementation:</p> <pre><code>struct ServerState {}\n\nimpl ServerState {\n    async fn set_brightness(&amp;mut self, value: f32) {\n        // do things\n    }\n}\n\nww_api!(\n    \"../../api/src/lib.rs\" as api::MyDevice for ServerState,\n    server = true, no_alloc = true, use_async = true,\n);\n</code></pre> <p><code>ww_api</code> proc-macro invocation will implement <code>process_request_bytes</code> function, which takes in request bytes, deserializes and processes them and eventually calls <code>set_brightness</code> on self.</p> <p>Note that you can request blocking implementation by setting <code>use_async = false</code>. And there is also a possibility to return values later, via a provided request id (for example if executing a method and getting a result takes a long time). More on that on the detailed page.</p>"},{"location":"api/overview/#streams","title":"Streams","text":"<p>Two types of streams are supported - from server to client (<code>stream!</code>) and from client to server (<code>sink!</code>). I.e., naming is from the perspective of the device (node) - stream out, sink in.</p> <pre><code>#[ww_trait]\ntrait MyDevice {\n    stream!(byte: u8);\n    sink!(word: u32);\n    stream!(slice: Vec&lt;u8&gt;);\n    sink!(user_defined: Vec&lt;LedState&gt;);\n}\n</code></pre> <p>Any type supported by the SerDes system works with streams as well. Streams can be used for many things, e.g., sending status updates or bytes from USART, frames to be transmitted on CAN bus, etc.</p> <p>Stream writes are not acknowledged - write message is sent out and no response is awaited by client, server publishes a stream update and similarly do not wait for any response from client. It is possible though to implement a token-based or some other form of backpressure using sideband channel.</p> <p>Streams can have a beginning and an end, for example to implement a file IO or firmware update, to deal with small chunks at a time and yet be able to signal a completion event. It is also possible to send a user defined delimiter, to be delivered in order with stream data, that can be used to implement frame synchronisation.</p> <p>Another useful property of streams is that they work on object level. For the <code>slice</code> stream in the example above, each individual array size is guaranteed to be preserved, even if multiple stream updates are transferred together at transport level. Sending <code>[1, 2, 3]</code>, <code>[4]</code>, <code>[5, 6]</code> will result in the same arrays received on the other end, in the same order.</p> <p>You can subscribe to stream updates, in an asynchronous or blocking manner, see more on the detailed page.</p>"},{"location":"api/overview/#properties","title":"Properties","text":"<p>Properties of any type can be defined as follows:</p> <pre><code>#[ww_trait]\ntrait MyDevice {\n    property!(ro button_pressed: bool);\n    property!(rw speed: f32);\n}\n</code></pre> <p>Property write is acknowledged by a server, unless request ID of 0 is used.</p> <p>Properties have access mode associated with them:</p> <ul> <li>Const (<code>const</code>) - property is not going to change, observe not available</li> <li>Read only (<code>ro</code>) - property can only be read, can change and be observed for changes</li> <li>Write only (<code>wo</code>) - property can only be written</li> <li>Read/Write (<code>rw</code>) - property can be read, written and observed for changes</li> </ul> <p>There are two supported way of implementing properties on the server side:</p> <ul> <li>get / set - user code provides <code>get_speed</code> and <code>set_speed</code> implementation.</li> <li>value / on_changed - generated code directly reads and writes <code>speed</code> field and calls user provided <code>speed_changed</code>   implementation.</li> </ul>"},{"location":"api/overview/#traits","title":"Traits","text":"<p>Traits in WireWeaver are used to define API blocks, as you can see from examples above, entry point for a device API is also a trait. They carry similar meaning to Rust traits, in a sense that trait defines some functionality, that server \"implements\" and client code can then interact with.</p> <p>But they are not actually traits under the hood, <code>#[ww_trait]</code> macro leaves only some static checks and removes the rest. Rust syntax is currently used to bypass writing a whole parser from scratch. All the magic happens through code generation in the <code>#[ww_api]</code> macro.</p>"},{"location":"api/overview/#traits-for-api-resources-grouping","title":"Traits for API resources grouping","text":"<p>Trait defined in the same file as the API root itself is a way to cleanly group related resources together.</p> <pre><code>#[ww_trait]\ntrait MyDevice {\n    ww_impl!(motor_control: MotorControl);\n    ww_impl!(led_control: LedControl);\n}\n\n#[ww_trait]\ntrait MotorControl {\n    fn turn_on();\n    fn turn_off();\n}\n\n#[ww_trait]\ntrait MotorControl {\n    fn led_on();\n    fn set_brightness(value: f32);\n}\n</code></pre> <p>Note that in this case, one additional path index will be used, so in total there will be 4 valid paths here:</p> <ol> <li>[0, 0] - <code>turn_on</code></li> <li>[0, 1] - <code>turn_off</code></li> <li>[1, 0] - <code>led_on</code></li> <li>[1, 1] - <code>set_brightness</code></li> </ol> <p>If preserving very small size is of big importance, try not to create too many levels. Also one can put more important functionality higher up, in order to leverage variable length encoding (e.g. numbers <code>0..=7</code> take only 4 bits on the wire).</p> <p>TODO: splitting into multiple files</p>"},{"location":"api/overview/#traits-global-for-extracting-common-functionality","title":"Traits (global) for extracting common functionality","text":"<p>The idea behind global traits is to leverage crates.io to define a set of common traits used across many devices. Device can then implement all the traits it needs and on the client side, common code can be used to control similar functionality of different devices.</p> <p>Traits generic enough to be global and currently planned are:</p> <ul> <li>FirmwareUpdate</li> <li>EmbeddedLog</li> <li>BoardInfo</li> <li>Counters</li> <li>Gpio</li> <li>DeviceUserInfo</li> <li>RegisterAccess</li> <li>CanBus</li> </ul> <p>Device API, instead of re-implementing the same things over and over, can the look like follows:</p> <pre><code>#[ww_trait]\ntrait MyAwesomeDevice {\n    ww_impl!(firmware_update: ww_firmware_update \"0.1.0\" :: FirmwareUpdate);\n    ww_impl!(board_info: ww_board_info \"0.1.0\" :: BoardInfo);\n    // and some device specific functionality in addition to common things\n}\n</code></pre> <p>Client code can be written in a completely agnostic way, e.g., only capable of interacting with <code>FirmwareUpdate</code> trait, regardless of which exact device it is implemented on or how it is physically connected.</p> <p>One can also interact with devices using trait-addressing mode, e.g., calling <code>set_indication_mode(Mode::Night)</code> on all devices on a CAN bus, putting all boards with LEDs into night mode. More on that on the addressing page</p>"},{"location":"api/overview/#resource-arrays","title":"Resource arrays","text":"<p>Any resource can also be an array - method, property, stream and even a trait implementation:</p> <pre><code>#[ww_trait]\ntrait ArrayOf {\n    fn run&lt;N: u32&gt;();\n    stream!(adc[]: u16);\n    property!(led[]: bool);\n    ww_impl!(motor[]: ww_motor_control \"0.1.0\" :: Motor);\n}\n</code></pre> <p>TODO: size bounds</p> <p>Traits inside other traits can also contain arrays, all the indices leading up to them are accumulated and passed as Rust array <code>[u32; N]</code> argument into a corresponding user handler.</p> <p>That way generated code can be kept efficient and simple, because the whole API tree is essentially flattened and simple function calls are used to interface with user provided implementation. At least that is the case for now on <code>no_std</code> targets.</p>"},{"location":"api/overview/#array-of-resources-vs-resource-of-array","title":"Array of resources vs resource of array","text":"<p>Here, resource led is itself an array, when accessing it - an index will be added to the resource path. Each one of three bool's is accessed separately from each other.</p> <pre><code>#[ww_trait]\ntrait ArrayOfResources {\n    property!(led[3]: bool);\n}\n</code></pre> <p>On the other hand, here led is not an array, but its type is. All three boolean's are accessed in one go.</p> <pre><code>#[ww_trait]\ntrait ResourceOfArrays {\n    property!(led: [bool; 3]);\n}\n</code></pre> <p>Both can be used together as well, for example:</p> <pre><code>#[ww_trait]\ntrait ArrayOfArrays {\n    property!(rgb_led[3]: [u8; 3]);\n}\n</code></pre>"},{"location":"api/versioning/","title":"Versioning","text":"<p>Each type and \"ww-trait\" version is it's crate version, same versioning rules apply. Types and \"ww-trait's\" are globally identified by their crate name and version. <code>FullVersion</code> type is provided in <code>ww_version</code> crate that carries crate name in addition to version numbers.</p>"},{"location":"evolution/rules/","title":"Evolution rules","text":"<p>There are two sets of evolution rules - one for data types and one for API.</p>"},{"location":"evolution/rules/#data-types","title":"Data types","text":"<p>WireWeaver considers two root types for evolution and evolution rule checks - <code>struct</code> and <code>enum</code> (plain and with data variants). Size of a type is marked as one of: <code>Unsized</code>, <code>FinalStructure</code>, <code>SelfDescribing</code> or <code>Sized</code>.</p>"},{"location":"evolution/rules/#unsized-types","title":"Unsized types","text":"<p>By default, user defined struct or enum is <code>Unsized</code>. Both can contain variable-size types - vectors, strings or other structs and enums. Unsized types support all the evolution options. It is recommended to stick with unsized types, unless extreme space-saving is required.</p> <p>When serializing, size of such objects is counted and written to the resulting byte array. Which is the only overhead, giving all the nice backwards and forwards compatibility features.</p> <ul> <li>New fields with default capability can be added to the end of structs, enum struct and tuple variants.<ul> <li><code>Option&lt;T&gt;</code> - None is read from old data,</li> <li><code>Vec&lt;T&gt;</code> - Empty vector is read from old data,</li> <li><code>String</code> - Empty string is read from old data,</li> <li><code>T</code> can be anything.</li> </ul> </li> <li>New <code>Sized</code> fields can be added into previously unused padding bits.</li> <li>TODO: clarify: <code>T</code> -&gt; struct containing <code>T</code></li> <li>Struct fields and enum variants can be renamed (but their position must NOT change).</li> </ul>"},{"location":"evolution/rules/#finalstructure-selfdescribing-and-sized-types","title":"FinalStructure, SelfDescribing and Sized types","text":"<ul> <li>New <code>Sized</code> fields can be added into previously unused padding bits.</li> <li>Struct fields and enum variants can be renamed (but their position must NOT change).</li> </ul>"},{"location":"evolution/rules/#api","title":"API","text":"<p>Data types used in API are a part of SemVer guarantee and are subject to the rules above. Meaning that it's not allowed to break compatibility on any of the data types used directly or indirectly without also bumping a major version of an API as well.</p> <ul> <li>Adding argument</li> <li><code>T</code> to struct of <code>T</code> in return position</li> <li><code>T</code> to <code>Vec&lt;T&gt;</code> in return position?</li> </ul>"},{"location":"evolution/rules/#api-model","title":"API model","text":"<p>API model (like <code>ww_client_server</code>) is part of the compatibility equation, it is not allowed to update the model version without breaking compatibility.</p> <p>E.g., if user_device_api v0.1.0 depends on ww_client_server v0.4.0 and a new major version of ww_client_server comes out (v0.5.0), then user_device_api must be bumped to v0.2.0 to use the newer API model. This should only happen to add new features though, and if previous version is doing all that it is supposed to, there might not be a need to upgrade.</p>"},{"location":"serdes/derive/","title":"Derive","text":"<p>Writing out serializing and deserializing code by hand would be very tedious and error-prone. So a procedural macro is provided that can create all the code.</p>"},{"location":"serdes/derive/#prerequisites","title":"Prerequisites","text":"<p>All examples below assume that wire_weaver dependency is added in Cargo.toml: <code>wire_weaver = \"0.4.0\"</code>.</p>"},{"location":"serdes/derive/#structs","title":"Structs","text":"<p>Simple example on how to automatically get serializing and deserializing code generated for a struct:</p> <pre><code>use wire_weaver::prelude::*;\n\n#[derive_shrink_wrap]\n#[derive(Debug, PartialEq)]\nstruct CoordV1 {\n    x: u8,\n    y: u8\n}\n\nfn derive_on_struct() {\n    let mut buf = [0u8; 64];\n    let coord = CoordV1 { x: 0xAA, y: 0xCC };\n    let bytes = to_ww_bytes(&amp;mut buf, &amp;coord).unwrap();\n    assert_eq!(bytes, &amp;[0xAA, 0xCC]);\n}\n</code></pre> <p>Let's evolve the type and try out the compatibility features:</p> <pre><code>#[derive_shrink_wrap]\n#[derive(Debug, PartialEq)]\nstruct CoordV1_1 {\n    x: u8,\n    y: u8,\n    #[default = None]\n    z: Option&lt;u8&gt;\n}\n\nfn evolved_struct() {\n    let mut buf = [0u8; 64];\n    let coord = CoordV1_1 { x: 0xAA, y: 0xCC, z: Some(0xFF) };\n    let bytes = to_ww_bytes(&amp;mut buf, &amp;coord).unwrap();\n    assert_eq!(bytes, &amp;[0xAA, 0xCC, 0x80, 0xFF]);\n    // newer type from older data\n    let coord: CoordV1_1 = from_ww_bytes(&amp;[0xAA, 0xCC]).unwrap();\n    assert_eq!(coord, CoordV1_1 { x: 0xAA, y: 0xCC, z: None });\n    // older type from newer data\n    let old_coord: CoordV1 = from_ww_bytes(bytes).unwrap();\n    assert_eq!(old_coord, CoordV1 { x: 0xAA, y: 0xCC });\n}\n</code></pre>"},{"location":"serdes/derive/#zero-copy-and-owned-types","title":"Zero-copy and owned types","text":"<p>Often there is a need to serialize owned type into a buffer and deserialize it as borrowed type on <code>no_std</code> without allocation or vice versa. Typing out two definitions, one using borrowed data (<code>RefVec&lt;'i, T&gt;</code>, <code>&amp;'i str</code>, etc.) and one owned would be very error-prone. Thus, <code>derive_shrink_wrap</code> attribute macro supports <code>#[owned = \"feature-name\"]</code> argument, that will trigger automatic generation of owned type definition and respective serialization and deserialization code.</p> <p>For example:</p> <pre><code>#[derive_shrink_wrap]\n#[owned = \"std\"]\npub struct FullVersion&lt;'i&gt; {\n    pub crate_id: &amp;'i str,\n    pub version: Version&lt;'i&gt;,\n}\n</code></pre> <p>Will generate <code>FullVersionOwned</code> along with serdes code that matches borrowed variant bit-to-bit.</p> <pre><code>#[cfg(feature = \"std\")]\npub struct FullVersionOwned {\n    pub crate_id: String,\n    pub version: VersionOwned,\n}\n</code></pre> <p>Pseudo-code usage example:</p> <pre><code>fn round_trip() {\n    // on no_std, no allocator\n    let v = FullVersion { .. };\n    let bytes = v.to_ww_bytes(&amp;mut buf).unwrap();\n\n    // on host, with allocator\n    let v_owned = FullVersionOwned::from_ww_bytes(bytes).unwrap();\n    assert_eq!(v.to_owned(), v_owned);\n\n    let bytes_from_owned = v_owned.to_ww_bytes(&amp;mut buf2).unwrap();\n    assert_eq!(bytes, bytes_from_owned);\n\n    // again on no_std\n    let v_ref = FullVersion::from_ww_bytes(bytes_from_owned).unwrap();\n    assert_eq!(v, v_ref);\n}\n</code></pre>"},{"location":"serdes/derive/#type-mapping","title":"Type mapping","text":"Borrowed type Owned equivalent <code>RefVec&lt;'i, u8&gt;</code> <code>Vec&lt;u8&gt;</code> <code>&amp;'i str</code> <code>String</code> <code>RefBox&lt;'i, T&gt;</code> <code>Box&lt;T&gt;</code> <code>UserType&lt;'i&gt;</code> <code>UserTypeOwned</code>"},{"location":"serdes/derive/#non-evolvable-types","title":"Non-evolvable types","text":"<p>final_structure, self_describing, sized</p>"},{"location":"serdes/derive/#next-step","title":"Next step","text":"<p>Check out API overview.</p>"},{"location":"serdes/shrink_wrap/","title":"Wire format","text":"<p>All serializing and deserializing operations are going through a wire format called <code>shrink_wrap</code>. It is targeting both microcontroller and host usage.</p> <p>Features:</p> <ul> <li>1-bit, 4-bit and 1-byte alignment</li> <li>Support all the types listed on the types page</li> <li><code>no_std</code> without allocator support (even with types like String and Vec, for both reading and writing)</li> <li><code>std</code> support (standard Vec and String are used)</li> <li>Zero-copy deserialization</li> <li>Self-referential types</li> <li>Built-in mechanism for backwards and forwards compatibility</li> </ul> <p>Used in auto-generated serdes and API code and it can be used stand-alone as well. Note that understanding how use serdes system manually is optional, as most of the code is automatically generated. Feel free to continue to the next step.</p>"},{"location":"serdes/shrink_wrap/#high-level-overview","title":"High-level overview","text":"<p>Main idea behind the wire format is a stack of sizes that is kept in the back of the buffer. This not only allows to do serialization in one pass, but also avoid unnecessary copying.</p> <p>Let's see how this works on a simple example: serialize two strings of arbitrary length into a byte buffer. One string is trivial, because assumption is that buffer length is known, hence two. Of course, we have to do it in such a way as to be able to get both strings back during deserialization stage, so we have to encode the lengths as well.</p> <p>Many formats are serializing length and then object bytes, like so: pic: l1 abc l2 qwerty</p> <p>There is a problem with this approach though: we need to know the object length, before we can write its bytes. Seems like a weird problem, because the string is right there, just use its length? But imagine that instead of a string, we are writing a complex object, consisting of many nested structs or even vectors of them.</p> <p>So we would either have to do a sizing pass and go through all that data first to figure out resulting length (and make sure its actually exactly correct).</p> <p>Or write a dummy length first, serialize the whole thing and then come back and fix the length. The trouble with that, is that we don't yet know how many bytes the length itself will take, and we would like to use variable length encoding to save space.</p> <p>We could limit the object size to e.g., 256 bytes, but this is unnecessarily small, while 65536 using 2 bytes is already too big for most things embedded. Or we could assume maximum length first, and then shift serialized bytes when we know the actual size, it would be nice to avoid this copy operation though.</p> <p>Core types of the wire format are - BufWriter and BufReader.</p> <p>Currently, both of them work on byte slices, though Vec based buffer is planned for more convenient use on std. There are no alignment requirements imposed on the slices (i.e., the alignment is 1 byte).</p>"},{"location":"serdes/shrink_wrap/#bufwriter","title":"BufWriter","text":"<p>BufWriter is created from a mutable byte slice (which does not have to be initialized to zero, potentially saving a bit of init time). BufWriter is keeping several indices into the provided slice to keep track of the current position.</p> <pre><code>use wire_weaver::shrink_wrap::prelude::*;\n\nfn simple_wr() {\n    let mut buf = [0u8; 256];\n    let mut wr = BufWriter::new(&amp;mut buf);\n    wr.write_bool(true).unwrap();\n    wr.write_u8(0xaa).unwrap();\n    let bytes = wr.finish().unwrap();\n    assert_eq!(bytes, &amp;[0x80, 0xaa]);\n}\n</code></pre>"},{"location":"serdes/shrink_wrap/#writeread-vs-ser_shrink_wrapdes_shrink_wrap","title":"write/read vs ser_shrink_wrap/des_shrink_wrap","text":"<p>write</p> <p>For Unsized types, size is read from the back of the buffer as reverse UNib32. Then split reader is used to actually deserialize the value.</p> <p>Note that values deserialized with this method must be serialized with write. Values serialized with ser_shrink_wrap must be deserialized with des_shrink_wrap.</p> <p>to_ww_bytes/from_ww_bytes</p>"},{"location":"serdes/shrink_wrap/#next-step","title":"Next step","text":"<p>Check out available macros that greatly simplify working with the wire format: derive.</p>"},{"location":"std_library/overview/","title":"Overview","text":"<p>The following crates provide types and traits that can be used in a variety of projects. Most of them depend only on <code>wire_weaver</code> itself.</p> <p>All the crates are <code>no_std</code>, when <code>default-features = false</code>. By default <code>std</code> feature is active providing owned types.</p> <ul> <li>ww_date_time<ul> <li><code>DateTime</code>: ISO 8601 combined date and time with optional time zone and optional nanoseconds.   Minimum size is 32 bits.</li> <li><code>NaiveDate</code>: ISO 8601 calendar date without timezone. Year stored as shifted by 2025, minimum size is 13 bits.</li> <li><code>NaiveTime</code>: ISO 8601 time without timezone. Size is 18 bits without nanoseconds and 49 bits with nanoseconds.</li> </ul> </li> <li>ww_version<ul> <li><code>Version</code>: SemVer version (including pre and build strings), no alloc</li> <li><code>VersionOwned</code>: SemVer version, same as <code>Version</code> but uses String's</li> <li><code>CompactVersion</code>: Global type id + major and minor version numbers, uses UNib32 for all three</li> </ul> </li> <li>ww_numeric<ul> <li><code>NumericValue</code>: value of the supported numeric types</li> <li><code>NumericBaseType</code>: discrete, floating and fixed point number types</li> <li><code>NumericAnyType</code>: base types + subtype and shift-scale</li> </ul> </li> <li>ww_si - SI and derived values using <code>NumericValue</code> as storage</li> <li>ww_client_server - <code>Request</code>, <code>RequestKind</code>, <code>Event</code>, <code>EventKind</code>, <code>Error</code> used for client-server API model.</li> <li>ww_can_bus - CAN Bus types and API</li> <li>ww_dfu - Firmware update API</li> <li>ww_log_bare_metal - Logging types and API for no_std bare metal targets</li> <li>ww_self - WireWeaver of WireWeaver itself for dynamic access to APIs, expression eval and introspection.</li> </ul>"},{"location":"std_library/ww_client_server/","title":"ww_client_server","text":"<p>API of an API for the lack of a better term (meta-API?)</p>"},{"location":"transport/overview/","title":"Overview","text":""},{"location":"transport/overview/#transport-protocols","title":"Transport protocols","text":"<p>Several transport protocols are supported:</p> <ul> <li>USB (nusb on host side, embassy on embedded, no drivers needed on Windows/Mac/Linux)</li> <li>WebSocket (for reliable control access)</li> <li>UDP (for telemetry)</li> <li>TODO: CAN Bus (using CANOpen)</li> </ul> <p>Others could be easily implemented, possibly reusing the same code.</p> <p>USB and UDP transports support multiple events per packet/datagram. Many small messages can be accumulated over a time window conserving bandwidth and allowing much higher message throughput per unit of time that would otherwise be possible with one message per packet/datagram.</p>"}]}