{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WireWeaver","text":"<p>WireWeaver is a wire format and API code generator for resource constrained systems (for example microcontrollers). It allows you to define data types, methods, properties and streams and generate code that uses no standard library or memory allocation. Unsized types - <code>Vec&lt;T&gt;</code>, String and others are supported (even on no_std without allocator!). Backwards and forwards compatibility is supported: devices with older format version can communicate with newer ones and vice versa.</p> <p>Currently only Rust language is supported, with the idea to handle device communications in Rust and provide higher level bindings for C++, Python or other languages if needed.</p> <p>Current state is - highly experimental.</p>"},{"location":"types/","title":"Built-in types","text":"<ul> <li>Boolean (one-bit alignment): <code>bool</code></li> <li>Discrete numbers:<ul> <li>Signed (one-byte alignment): <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code></li> <li>Unsigned (one-byte alignment): <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></li> <li>Unsigned (four-bit alignment): <code>u4</code></li> <li>Signed and unsigned (one-bit alignment): <code>iN</code> and <code>uN</code> (<code>U1</code>, <code>U2</code>, <code>U3</code>, ... <code>U64</code>, <code>I2</code> ... <code>I64</code>)</li> </ul> </li> <li>Nibble-based variable length u32: <code>UNib32</code> (1 to 11 nibbles)</li> <li>Floating point numbers: <code>f32</code>, <code>f64</code></li> <li>Textual:<ul> <li>UTF-8 string <code>String</code></li> <li>TODO: With max bounded length</li> </ul> </li> <li>Sequences:<ul> <li>Arrays:<ul> <li>Arbitrary length array: <code>Vec&lt;T&gt;</code></li> <li>Byte array: <code>Vec&lt;u8&gt;</code></li> <li>Arbitrary length array (no alloc): <code>RefVec&lt;'i, T&gt;</code></li> <li>Byte array (no alloc): <code>RefVec&lt;'i, u8&gt;</code></li> <li>TODO: Max bounded</li> <li>TODO: Fixed length array: <code>[T; N]</code></li> </ul> </li> </ul> </li> <li><code>Option&lt;T&gt;</code> and <code>Result&lt;T, E&gt;</code></li> <li><code>RefBox&lt;T&gt;</code> for self-referential types.</li> <li> <p>User-defined:</p> <ul> <li>Struct</li> <li>Enum with or without data variants</li> </ul> </li> <li> <p>Not yet supported or not decided whether to support:</p> <ul> <li>Tuple</li> <li>Unicode character: <code>char</code> (4B)</li> <li>ASCII character <code>c_char</code> (1B) (ASCII) and string: <code>c_str</code></li> <li>Map</li> </ul> </li> </ul>"},{"location":"types/#library-types","title":"Library types","text":"<p>There are a lot more types as a part of a standard library (date, time, version, numbers, SI units, etc.). See the overview.</p>"},{"location":"types/#self-referential-types","title":"Self-referential types","text":"<p>Self-referential types are supported through the <code>RefBox&lt;T&gt;</code>, providing similar semantics to Rust <code>Box&lt;T&gt;</code> type, but without using heap allocation on <code>no_std</code>.</p>"},{"location":"types/#alignment","title":"Alignment","text":"<p>Some types are one- or four-bit aligned and the rest are one-byte aligned. Dense packing is used to save space, including in enum discriminants (which can even be U1). Byte arrays, strings, and Unsized objects are all one-byte aligned to limit code complexity and computations required. Unused bits are set to zero and can be reclaimed when evolving a type.</p> <p>For example:</p> <pre><code>fn version1() {\n    let mut buf = [0u8; 8];\n    let mut wr = BufWriter::new(&amp;mut buf[..]);\n    wr.write_bool(true).unwrap();\n    wr.write_u8(0xAA).unwrap();\n    let bytes = wr.finish_and_take().unwrap();\n    assert_eq!(bytes, &amp;[0x80, 0xAA]);\n}\n</code></pre> <p>In a future version while older one is still in use, it was decided to add some more data:</p> <pre><code>fn version1_1() {\n    let mut buf = [0u8; 8];\n    let mut wr = BufWriter::new(&amp;mut buf[..]);\n    wr.write_bool(true).unwrap();\n    wr.write(&amp;Some(U6::new(5).unwrap())).unwrap();\n    wr.write_u8(0xAA).unwrap();\n    let bytes = wr.finish_and_take().unwrap();\n    assert_eq!(bytes, &amp;[0xC5, 0xAA]);\n}\n</code></pre> <p>Older code can still read new data and will skip the Option, and newer code can read old data, yielding None. All the while, the serialized size didn't even change (it could have though, it's just an example).</p>"},{"location":"api/addressing/","title":"API resources addressing","text":"<p>Primary mode of addressing to uniquely identify a resource (method, property, stream or trait) is an array of indices, starting from an API root. It is the most efficient way as well, utilising UNib32 variable length numbers based on nibbles (e.g., <code>[0, 1, 2]</code> is only 2 bytes, including array length).</p> <p>For example, <code>turn_on</code> address is <code>[0]</code> and <code>turn_off</code> is <code>[1]</code>.</p> <pre><code>#[ww_trait]\ntrait ApiRoot {\n    fn turn_on();\n    fn turn_off();\n}\n</code></pre> <p>As a user, you do not have to worry about these indices, as they are automatically assigned and actual names are used in generated code.</p> <p>When a resource is an array, one more index is added, selecting the required one. On the server code side this index is passed as an additional argument to user handler function.</p> <p>There could be multiple arrays on the way to a resource (e.g., array of trait implementations and then an array of resources inside said trait). Multiple indices are added in the appropriate positions in this case.</p> <p>Using this scheme requires knowing exactly which API and it's exact version that peer implements. When this is not possible or not desired (e.g., if addressing multiple nodes at the same time) - trait addressing can be used.</p>"},{"location":"api/addressing/#trait-addressing-fullversion","title":"Trait addressing (FullVersion)","text":"<p>There is a possibility to make API calls on \"ww-traits\", without knowing the exact resource address. For example one could make a \"sleep\" call on all devices in a CAN Bus network, that support \"PowerManagement\" trait. Or \"get_fw_version\" on any device supporting \"FirmwareInfo\" trait. In order to do so, instead of relying on resource address, <code>FullVersion</code> is sent instead.</p> <p>Compared to resource addresses that can only take a few bytes, <code>FullVersion</code> is likely to take about 8-16 bytes or more and vary with the crate name. This is unfortunate for constrained systems, or if one wants to pack many calls into one packet.</p>"},{"location":"api/addressing/#trait-addressing-compactversion","title":"Trait addressing (CompactVersion)","text":"<p>Solution to this is <code>CompactVersion</code>, which carries globally unique type id and major.minor version components only, all UNib32 encoded. The only downside is that guaranteeing globally unique IDs is not as simple as using crate's name anymore. IDs are manually assigned and tracked via git instead.</p>"},{"location":"api/resources/","title":"API","text":"<p>Define a custom protocol as collections of resources - methods, properties or streams and generate server and client side code. Multiple levels are supported, each resource is identified via a number path from root, forming a tree. Efficient path is used, consisting of UNib32 encoded numbers, taking as little as 4 bits.</p> <p>Resources can be arranged into \"ww-trait's\" and then \"implemented\" at various points in the API tree. Accessing them is possible in the same manner via resource paths, or through their globally unique ID (crate name + version or unique ID + version). Many useful \"ww-traits\" are planned, implementing things like firmware update, event counters, logging, power management, etc. That way code to handle them all can be reused greatly between very different projects. UI can also be arranged into small reusable blocks.</p> <p>Two models are planned: client-server and bus. Client-server model is functional (<code>ww_client_server</code> crate) and supported in code generation for both server and client side, std and no_std. Bus model is still in development.</p>"},{"location":"api/resources/#methods","title":"Methods","text":""},{"location":"api/resources/#async-and-sync","title":"Async and sync","text":""},{"location":"api/resources/#deferred-and-immediate","title":"Deferred and Immediate","text":""},{"location":"api/resources/#streams","title":"Streams","text":"<pre><code>trait Log {\n    fn defmt_bytes() -&gt; Stream&lt;u8&gt;;\n    fn sink(stream_in: Sink&lt;u8&gt;);\n}\n</code></pre>"},{"location":"api/resources/#properties","title":"Properties","text":""},{"location":"api/resources/#getset-and-value-on-change","title":"Get/Set and value on change","text":""},{"location":"api/resources/#traits","title":"Traits","text":""},{"location":"api/resources/#user-handler-flattening-no_std","title":"User handler flattening (no_std)","text":""},{"location":"api/resources/#resource-arrays","title":"Resource arrays","text":"<p>Any resource can also be an array - method, property, stream and trait implementation:</p> <pre><code>trait ArrayOf {\n    fn run&lt;N: u32&gt;();\n    stream!(adc[]: u16);\n    property!(led[]: bool);\n    ww_impl!(motor[]: ww_motor_control::Motor);\n}\n</code></pre> <p>TODO: size bounds</p> <p>Traits inside other traits can also contain arrays, all the indices leading up to them are accumulated and passed as Rust array <code>[u32; N]</code> argument into a corresponding user handler.</p>"},{"location":"api/resources/#array-of-resources-vs-resource-of-array","title":"Array of resources vs resource of array","text":"<p>Here, resource led is itself an array, when accessing it - an index will be added to the resource path. Each one of three bool's is accessed separately from each other.</p> <pre><code>trait ArrayOfResources {\n    property!(led[3]: bool);\n}\n</code></pre> <p>On the other hand, here led is not an array, but it's type is. All three boolean's are accessed in one go.</p> <pre><code>trait ResourceOfArrays {\n    property!(led: [bool; 3]);\n}\n</code></pre> <p>Both can be used together as well, for example:</p> <pre><code>trait ArrayOfArrays {\n    property!(rgb_led[3]: [u8; 3]);\n}\n</code></pre>"},{"location":"api/resources/#transport-protocols","title":"Transport protocols","text":"<p>Several transport protocols are supported:</p> <ul> <li>USB (nusb on host side, embassy on embedded, no drivers needed on Windows/Mac/Linux)</li> <li>WebSocket (for reliable control access)</li> <li>UDP (for telemetry)</li> <li>TODO: CAN Bus (using CANOpen)</li> </ul> <p>Others could be easily implemented, possibly reusing the same code.</p> <p>USB and UDP transports support multiple events per packet/datagram. Many small messages can be accumulated over a time window conserving bandwidth and allowing much higher message throughput per unit of time that would otherwise be possible with one message per packet/datagram.</p>"},{"location":"api/versioning/","title":"Versioning","text":"<p>Each type and \"ww-trait\" version is it's crate version, same versioning rules apply. Types and \"ww-trait's\" are globally identified by their crate name and version. <code>FullVersion</code> type is provided in <code>ww_version</code> crate that carries crate name in addition to version numbers.</p>"},{"location":"evolution/rules/","title":"Evolution rules","text":"<p>There are two sets of evolution rules - one for data types and one for API.</p>"},{"location":"evolution/rules/#data-types","title":"Data types","text":"<p>WireWeaver considers two root types for evolution and evolution rule checks - <code>struct</code> and <code>enum</code> (plain and with data variants). Size of a type is marked as one of: <code>Unsized</code>, <code>FinalStructure</code>, <code>SelfDescribing</code> or <code>Sized</code>.</p>"},{"location":"evolution/rules/#unsized-types","title":"Unsized types","text":"<p>By default, user defined struct or enum is <code>Unsized</code>. Both can contain variable-size types - vectors, strings or other structs and enums. Unsized types support all the evolution options. Is it recommended to stick with unsized types, unless extreme space-saving is required.</p> <p>When serializing, size of such objects is counted and written to the resulting byte array. Which is the only overhead, giving all the nice backwards and forwards compatibility features.</p> <ul> <li>New fields with default capability can be added to the end of structs, enum struct and tuple variants.<ul> <li><code>Option&lt;T&gt;</code> - None is read from old data,</li> <li><code>Vec&lt;T&gt;</code> - Empty vector is read from old data,</li> <li><code>String</code> - Empty string is read from old data,</li> <li><code>T</code> can be anything.</li> </ul> </li> <li>New <code>Sized</code> fields can be added into previously unused padding bits.</li> <li>Struct fields and enum variants can be renamed (but their position must NOT change).</li> </ul>"},{"location":"evolution/rules/#finalstructure-selfdescribing-and-sized-types","title":"FinalStructure, SelfDescribing and Sized types","text":"<ul> <li>New <code>Sized</code> fields can be added into previously unused padding bits.</li> <li>Struct fields and enum variants can be renamed (but their position must NOT change).</li> </ul>"},{"location":"evolution/rules/#api","title":"API","text":"<p>Data types used in API are a part of SemVer guarantee and are subject to the rules above. Meaning that it's not allowed to break compatibility on any of the data types used directly or indirectly without also bumping a major version of an API as well.</p>"},{"location":"std_library/overview/","title":"Standard library types overview","text":"<ul> <li>ww_numeric<ul> <li><code>NumericValue</code>: value of the supported numeric types</li> <li><code>NumericBaseType</code>: discrete, floating and fixed point number types</li> <li><code>NumericAnyType</code>: base types + subtype and shift-scale</li> </ul> </li> <li>ww_si - SI and derived values using <code>NumericValue</code> as storage</li> <li>ww_date_time<ul> <li><code>DateTime</code>: ISO 8601 combined date and time with optional time zone and optional nanoseconds.   Minimum size is 32 bits.</li> <li><code>NaiveDate</code>: ISO 8601 calendar date without timezone. Year stored as shifted by 2025, minimum size is 13 bits.</li> <li><code>NaiveTime</code>: ISO 8601 time without timezone. Size is 18 bits without nanoseconds and 49 bits with nanoseconds.</li> </ul> </li> <li>ww_version<ul> <li><code>Version</code>: SemVer version (including pre and build strings), no alloc</li> <li><code>VersionOwned</code>: SemVer version, same as <code>Version</code> but uses String's</li> <li><code>CompactVersion</code>: Global type id + major and minor version numbers, uses UNib32 for all three</li> </ul> </li> <li>ww_client_server - <code>Request</code>, <code>RequestKind</code>, <code>Event</code>, <code>EventKind</code>, <code>Error</code> used for client-server API model.</li> <li>ww_can_bus - CAN Bus types and API</li> <li>ww_dfu - Firmware update API</li> <li>ww_log_bare_metal - Logging types and API for no_std bare metal targets</li> <li>ww_self - WireWeaver of WireWeaver itself for dynamic access to APIs, expression eval and introspection.</li> </ul>"},{"location":"std_library/ww_client_server/","title":"ww_client_server","text":"<p>API of an API for the lack of a better term (meta-API?)</p>"},{"location":"wire_format/shrink_wrap/","title":"Wire format","text":"<p>All serializing and deserializing operations are going through a wire format called <code>shrink_wrap</code>. It is targeting both microcontroller and host usage.</p> <p>Features:</p> <ul> <li>1-bit, 4-bit and 1-byte alignment</li> <li>Support all the types described above</li> <li><code>no_std</code> without allocator support (even with types like String and Vec, for both reading and writing)</li> <li><code>std</code> support (standard Vec and String are used)</li> <li>Used in auto-generated serdes and API code</li> <li>Can be used stand-alone as well</li> </ul>"}]}