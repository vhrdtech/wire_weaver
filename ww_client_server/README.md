# ww_client_server

> Client-server API model data types for both no_std and std.

This crate is mostly used by WireWeaver itself in generated code, but some types are provided to user code.

By default, this crate is `std`, so when using on a firmware side, use:
`ww_client_server = { version = "0.4.0", default-features = false }` in Cargo.toml.

## Simplified example

Suppose that you've defined the following API for your device:

```rust,ignore
#[ww_trait]
pub trait MyDevice {
    fn led_on();
    fn led_off();
}
```

WireWeaver will then generate approximately the following code on the client side:

```rust,ignore
pub struct MyDeviceClient {}

// automatically generated by ww_api macro
impl MyDeviceClient {
    pub async fn led_on(&mut self) -> Result<(), Error> {
        let seq = 123; // obtain next request ID 
        let req = Reqeust {
            seq,
            path_kind: PathKind::Absolute { path: [0] },
            kind: ReqeustKind::Call { args: [] }
        };
        let bytes = req.to_ww_bytes()?;
        transport.send(bytes);
        let response = transport.filter_for_event(seq).await?;
        let _response = Event::from_ww_bytes(response);
        // no arguments, so just return
    }

    // similar code for other resources
}
```

And for the server side:

```rust,ignore
pub struct MyDeviceServer {}

// automatically generated by ww_api macro
impl MyDeviceServer {
    pub fn process_request_bytes(&mut self, bytes: &[u8]) -> Result<(), Error> {
        let request = Request::from_ww_bytes(bytes)?;
        // for simplicity assuming only Absolute path here
        match request.path {
            [0] => {
                // no args to deserialize, call right away
                self.led_on();
                // send Ok Event back
            }
            // other resources 
            _ => { /* serialize and send BadPath error back */ }
        }
    }
}
```

The only user provided code is the actual implementation of two methods:

```rust,ignore
impl MyDeviceServer {
    pub fn led_on(&mut self) {
        // your code 
    }

    pub fn led_off(&mut self) {
        // your code 
    }
}
```

Other resources work in a similar way.

So in a sense, this crate is an API for an API (is meta-API a thing?).